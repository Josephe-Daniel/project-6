// IMPORT PACKAGE
const fs = require("fs");

// IMPORT SAUCE MODEL
const Sauce = require("../models/Sauce");

// EXPORT ALL BUSINESS LOGIC CONCERNING SAUCE ROUTES:
// SAUCE MODEL INSTANCE
/**
 * The request body contains a string "sauce",
 * which is simply a Sauce object converted to a string.
 * Parse it using JSON.parse() to get a usable object.
 * Deletes the field_userId from the request sent by the client.
 * Since "req.file.filename" only contains the filename segment,
 * resolves the full image URL.
 * Use "req.protocol" to get the first segment (in our case 'http').
 * Add '://', ​​then use "req.get('host')"
 * to resolve the server host (here, 'localhost:3000').
 * Finally add '/images/' and the filename to complete our URL.
 * The save() method saves the "Sauce" in the database,
 * and it returns a Promise.
 * The then() block returns a success response with a 201 success code.
 * The catch() block returns a response with the error generated by Mongoose
 * as well as a 400 error code.
 * @param {Object} req  The request object
 * @param {Object} res  The response object
 */
exports.createSauce = async (req, res) => {
  try {
    const sauceObject = JSON.parse(req.body.sauce);
    delete sauceObject._id;
    delete sauceObject._userId;
    const sauce = new Sauce({
      ...sauceObject,
      userId: req.auth.userId,
      imageUrl: `${req.protocol}://${req.get("host")}/images/${
        req.file.filename
      }`,
    });
    await sauce.save();
    return res.status(201).json({ message: "Sauce created !" });
  } catch (error) {
    return res.status(500).json({ error });
  }
};

// DISPLAY ALL SAUCES
/**
 * Use the find() method in the "Sauce" model
 * in order to return an array containing all the Sauces in our database.
 * @param {Object} req  The request object
 * @param {Object} res  The response object
 */
exports.getAllSauces = async (req, res) => {
  try {
    const sauces = await Sauce.find({});
    return res.status(200).json(sauces);
  } catch (error) {
    return res.status(500).json({ error });
  }
};

// DISPLAY A SAUCE WITH ITS ID
/**
 * Uses the findOne() method in the "Sauce" model to find the single "Sauce"
 * having the same "_id" as the query parameter.
 * This "Sauce" is then returned in a Promise and sent to the front-end.
 * If no "Sauce" is found or an error occurs:
 * sends a "404 error" to the front-end, along with the generated error.
 * @param {Object} req  The request object
 * @param {Object} res  The response object
 */
exports.getOneSauce = async (req, res) => {
  try {
    const sauce = await Sauce.findById({ _id: req.params.id });
    if (!sauce) {
      throw res.status(404).json({ message: "Sauce does not exist !" });
    }
    return res.status(200).json(sauce);
  } catch (error) {
    return res.status(500).json({ error });
  }
};

// MODIFY A SAUCE
/**
 * Create a "sauceObject" which checks if "req.body.sauce" exists or not.
 * If it exists, convert it to an Object.
 * if it does not exist, we simply process the incoming object.
 * Removes the _userId field sent by the client to avoid changing its owner
 * Then search the "sauce" by its ID,
 * and verifies that the requestor is the owner of the object:
 *  - if its Ok:
 *    - check if "req.file" is asked:
 *      in this case a new image is processed and the old is deleted
 *      (return a status(500) with an error message if the picture does not exist)
 *    - Update the sauce
 *      (return a status(200) with a notification message)
 *  - if the requestor is not the owner of the object (the sauce):
 *    -  return a status(403) with a message
 * then makes the change.
 * @param {Object} req  The request object
 * @param {Object} res  The response object
 */
exports.modifySauce = async (req, res) => {
  try {
    const idSauce = req.params.id;
    const idAuthUser = req.auth.userId;
    const sauceObject = req.body.sauce ? JSON.parse(req.body.sauce) : req.body;
    delete sauceObject._userId;

    const sauce = await Sauce.findById({ _id: idSauce });
    if (sauce.userId === idAuthUser) {
      if (req.file) {
        const filename = await sauce.imageUrl.split("/images/")[1];
        fs.unlink(`images/${filename}`, async (error) => {
          sauceObject.imageUrl = `${req.protocol}://${req.get("host")}/images/${
            req.file.filename
          }`;
          if (error) {
            return res
              .status(500)
              .json({ error, message: "Picture does not exist" });
          } else {
            await Sauce.findByIdAndUpdate(
              { _id: idSauce },
              {
                imageUrl: sauceObject.imageUrl,
              }
            );
            console.error(
              "Original Image successfully removed from 'images' folder"
            );
          }
        });
      }
      await Sauce.findByIdAndUpdate(
        { _id: idSauce },
        { ...sauceObject, _id: idSauce }
      );
      return res.status(200).json({ message: "Sauce modified !" });
    } else {
      return res.status(403).json({ message: "Unauthorized request." });
    }
  } catch (error) {
    return res.status(500).json({ error });
  }
};

// DELETE A SAUCE
/**
 * Use the ID received as a parameter to access the "Sauce"
 * corresponding in the database.
 * Checks if the user who made the deletion request
 * is the one who created the "Sauce".
 * Uses knowing that the image URL contains a segment
 * "/images/" to separate the filename.
 * Then use the unlink() function of the "fs" package
 * to delete this file by passing it the file to delete
 * and the callback to execute once this file is deleted.
 * In the callback, implement the original logic by removing
 * the "Sauce" of the database.
 */
exports.deleteSauce = async (req, res) => {
  try {
    const idSauce = req.params.id;
    const idAuthUser = req.auth.userId;
    const sauce = await Sauce.findById({ _id: idSauce });

    if (sauce.userId === idAuthUser) {
      const filename = await sauce.imageUrl.split("/images/")[1];
      fs.unlink(`images/${filename}`, (error) => {
        if (error) {
          res.status(500).json({ error, message: "Picture does not exist" });
        } else {
          console.error("Image successfully deleted from 'images' folder");
        }
      });
      await Sauce.findByIdAndDelete({ _id: idSauce });
      return res.status(200).json({ message: "Sauce deleted !" });
    } else {
      return res.status(403).json({ message: "Unauthorized request." });
    }
  } catch (error) {
    res.status(500).json({ error });
  }
};

// SYSTEM LIKE & DISLIKE
/**
 * Check If user already like the sauce
 * If user not already liked or disliked:
 *  - Click on Like button:
 *    return 1 and add "userId" to "usersLiked"
 *    and increment "likes" by 1 like.
 *  - Click on Dislike button:
 *    return -1 and add "userId" to "usersdisLiked"
 *    and increment "dislikes" by 1 dislike.
 * If user has already liked:
 *  - Click on Like button:
 *    remove "userId" from "usersLiked"
 *    and decrement "likes" by -1 like
 * If user has already disliked:
 *  - Click on Dislike button:
 *    remove "userId" from "usersDisliked"
 *    and decrement "dislikes" by -1 dislike
 * @param {Object} req  The request object
 * @param {Object} res  The response object
 */
exports.likeSauce = async (req, res) => {
  try {
    const like = req.body.like;
    const idSauce = req.params.id;
    const idUser = req.body.userId;
    const sauce = await Sauce.findById({ _id: idSauce });
    const alreadyLiked = sauce.usersLiked.includes(idUser);
    const alreadyDisliked = sauce.usersDisliked.includes(idUser);

    switch (like) {
      case 1:
        if (!alreadyLiked || !alreadyDisliked) {
          await Sauce.findByIdAndUpdate(
            { _id: idSauce },
            {
              $push: { usersLiked: idUser },
              $inc: { likes: +1 },
            }
          );
          return res.status(200).json({ message: "Like added" });
        }
        break;
      case -1:
        if (!alreadyLiked || !alreadyDisliked) {
          await Sauce.findByIdAndUpdate(
            { _id: idSauce },
            {
              $push: { usersDisliked: idUser },
              $inc: { dislikes: +1 },
            }
          );
          return res.status(200).json({ message: "Dislike added" });
        }
        break;
      case 0:
        if (alreadyLiked) {
          await Sauce.findByIdAndUpdate(
            { _id: idSauce },
            {
              $pull: { usersLiked: idUser },
              $inc: { likes: -1 },
            }
          );
          return res.status(200).json({ message: "Like removed" });
        }
        if (alreadyDisliked) {
          await Sauce.findByIdAndUpdate(
            { _id: idSauce },
            {
              $pull: { usersDisliked: idUser },
              $inc: { dislikes: -1 },
            }
          );
          return res.status(200).json({ message: "Dislike removed" });
        }
        break;
    }
  } catch (error) {
    res.status(500).json({ error });
  }
};
